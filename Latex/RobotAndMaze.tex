\documentclass[12pt]{article}

\usepackage{graphicx} % to include figures
%\graphicspath{{Figures/}} %This can be used if figures are in a folder in the Latex path
%\graphicspath{{../Matlab/MainProject/Figures/}} %Setting the graphics path
\usepackage{float} % to force figure placement with [H]
\usepackage{geometry} % to set the page size and margins
\geometry{a4paper, margin=2.5cm}
\usepackage{amsmath,amsthm,amssymb} % enables subequations and aligned
\usepackage{matlab-prettifier} % to import MATLAB code
\usepackage[hidelinks]{hyperref} % enable hyperlinks (boxes hidden)
\usepackage{pgf} % enable pgf figures
\usepackage{siunitx} % enable SI units and notation
\usepackage{arydshln} % for partitioned matrices with dashed lines

\usepackage{datetime2}

\usepackage{esint}
\usepackage{pxfonts}

\usepackage{tkz-euclide}

%% packages for pfg plots from MATLAB's exported tex files
%% See https://github.com/matlab2tikz/matlab2tikz for details
\usepackage{pgfplots}
\pgfplotsset{compat=newest}
%% The following commands are needed for some matlab2tikz features
\usetikzlibrary{plotmarks}
\usetikzlibrary{arrows.meta}
\usepgfplotslibrary{patchplots}
\usepackage{grffile}
%% You may also want the following commands
%\pgfplotsset{plot coordinates/math parser=false}
%\newlength\figureheight
%\newlength\figurewidth

\usepackage[numbib]{tocbibind} % give the references section a section number

\numberwithin{equation}{section} % label equations by sectoins
\numberwithin{figure}{section} % label equations by sectoins

\newenvironment{problem}[2][Problem]{\begin{trivlist}
		\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}

\begin{document}
	
\title{Robot and Maze Problem}
\author{Charl van de Merwe \\ University of Witwatersrand}
\date{\today}

\maketitle

\section{Introduction}

In this problem the circular robot with two rigid drive wheels, the {\color{blue} \href{https://edu.irobot.com/what-we-offer/create3}{iRobot Create 3}} (see Fig. \ref{fig:iRobot} and Fig. \ref{fig:iRobotBottom}), should run through a maze, Fig. \ref{fig:Maze}, in minimum time.

\begin{figure}[h!]
	\centering
	\begin{minipage}[b]{0.45\textwidth}
		\centering
		\includegraphics[width=7cm]{Figures/iRobot.jpg}
		\caption{iRobot Create 3}
		\label{fig:iRobot}
	\end{minipage}
	\hfill
	\begin{minipage}[b]{0.45\textwidth}
		\centering
		\includegraphics[width=7cm]{Figures/iRobotBottom.png}
		\caption{Bottom of the robot.}
		\label{fig:iRobotBottom}
	\end{minipage}
\end{figure}

\begin{figure}[h!]
	\centering
	\includegraphics[width=8cm]{Figures/Maze.png}
	\caption{The maze from the 2018 APEC Micromouse competition. Each cell is 1m by 1m.}
	\label{fig:Maze}
\end{figure}

I was introduced to the problem my a friend at Wits, who is solving this problem with reinforcement learning. He will solve it in simulation, using the {\color{blue} \href{https://github.com/Yurof/WheeledRobotSimulations}{WheeledRobotSimulations}} GitHub repository. This repository uses the {\color{blue} \href{https://github.com/bulletphysics/bullet3}{PyBullet}} library for the robot dynamics.

\section{Model}

I have not found the details of the exact model used in PyBullet in any of the documentation found on its {\color{blue} \href{https://pybullet.org/wordpress/}{website}}. From what I've gathered, it doesn't seem like they do any complex tyre modelling.

Assuming zero slip (very high adhesion conditions or low speed with high normal forces), the torque of the motor is directly translated to adhesion force:
\begin{equation}\label{eq:Force}
	F = T / r,
\end{equation}
where $F$ is the adhesion force, $T$ is the motor torque, and $r$ is the wheel radius.

The longitudinal dynamics of the robot are:
\begin{equation}
	m \, \dot v = F_R + F_L,
\end{equation}
where $m$ is the mass of the robot, $v$ is the longitudinal velocity, and $F_R$ and $F_L$ are the right and left wheel adhesion forces.

The rotational dynamics of the robot are:
\begin{equation}
	I \, \dot \omega = w \, (F_R - F_L),
\end{equation}
where $I$ is the robot inertia, $\omega$ is the angular velocity, and $w$ is the distance from the center of gravity (CoG) to a wheel (it is assumed the CoG is in the middle of the robot).

The position of the robot is tracked by adding the the following to the model:
\begin{align}
	\dot x &= v \cos \theta \\
	\dot y &= v \sin \theta,
\end{align}
where $x$ and $y$ are the x and y locations of the robot, and $\theta$ is the robot angle relative to the x-axis.

The state vector is chosen as:
\begin{equation}
	\boldsymbol{x} = \begin{bmatrix}
		v & \theta & x & y & \omega
	\end{bmatrix}^T,
\end{equation}
Therefore, the model is:
\begin{equation}
	\boldsymbol{\dot x} = \begin{bmatrix}
		\frac{1}{m} (F_R + F_L) \\
		\omega \\
		v \cos \theta \\
		v \sin \theta \\
		\frac{w}{I} \, (F_R - F_L)
	\end{bmatrix},
\end{equation}
where the forces, $F_R$ and $F_L$, are the inputs (controlled variables).

The model parameters values are given in Table \ref{tab:Model}.
\begin{table}[h!]
	\centering
	\begin{tabular}{c c c}
		\hline
		\textbf{Parameter} & \textbf{Description} & \textbf{Value} \\ \hline
		$m$ & Robot mass. & $5.925$ $\mathrm{kg}$ \\ \hline
		$I$ & Robot inertia. & $^* 0.0836$ $\mathrm{kg \, m^2}$ \\ \hline
		$w$ & Distance from wheel to CoG. & $0.13$ $\mathrm{m}$ \\ \hline
		$r$ & Wheel radius. & $0.03$ $\mathrm{m}$ \\ \hline
		$r_\mathrm{Robot}$ & Robot radius. & $0.168$ $\mathrm{m}$ \\ \hline
	\end{tabular}
	\caption{Model parameters. *The inertia is calculated by assuming the robot is a cylinder with a uniform weight distribution. Therefore, $I = 0.5 \, m \, r_\mathrm{Robot}^2$.}
	\label{tab:Model}
\end{table}

\section{Model Validation}

To test the model, a simulation is run with constant forces, with the right force set higher than the left force. The longitudinal velocity should increase at a constant acceleration, and the robot is expected to run in circles.

Please see the GitHub repository, {\color{blue} \href{https://github.com/CharlvdM/RobotAndMaze}{RobotAndMaze}}, I have created containing the MATLAB and Latex code.


\section{First GPOPS-II Simulation}

The maze boundaries should be computed as $x$ and $y$ state constraints based on the location of the robot. GPOPS will not be used to solve the maze. Rather, the incorrect routes will be closed, so that the solved maze is like a racetrack with sharp corners.

\subsection{Boundary Conditions}

Before creating a complex simulation with the full track (solved maze), a problem with the following start and final conditions is constructed, where the objective is to reach the final conditions in minimum time:
\begin{equation}
	\begin{matrix}
		v_0 = 0, & \theta_0 = 0, & x_0 = 0, & y_0 = 0, & \omega_0 = 0, \\
		& \theta_f = 0, & x_f = 20, & y_f = 10. &
	\end{matrix} \nonumber
\end{equation}

\subsection{Limits}
\label{sec:Limits}

The velocity limit in the {\color{blue} \href{https://github.com/Yurof/WheeledRobotSimulations}{WheeledRobotSimulations}} project was set to $16.5$ $\mathrm{m/s}$. From the given boundary conditions, the robot isn't expected to ever do more than a full rotation. The position limits are set slightly outside of the boundary conditions. The angular rate is not expected to be very high. Therefore:
\begin{equation}
	\begin{matrix}
		v_\mathrm{min} = -16.5, & v_\mathrm{max} = 16.5 \\
		\theta_\mathrm{min} = - 2 \pi & \theta_\mathrm{max} = 2 \pi \\
		x_\mathrm{min} = - 10 & x_\mathrm{max} = 25 \\
		y_\mathrm{min} = - 10 & y_\mathrm{max} = 20 \\
		\omega_\mathrm{min} = - 10 & \omega_\mathrm{max} = 10
	\end{matrix} \nonumber
\end{equation}

There is a force limit specified as $20$ (without a unit) in the {\color{blue} \href{https://github.com/Yurof/WheeledRobotSimulations}{WheeledRobotSimulations}} project, which is passed to the motor control function of the {\color{blue} \href{https://github.com/bulletphysics/bullet3}{PyBullet}} library. Therefore, I assumed this was a torque limit, and set the force limit blindly from (\ref{eq:Force}), i.e.:
\begin{equation}
	\begin{matrix}
		F_{R/L \, \mathrm{min}} = -666.7, & F_{R/L \, \mathrm{max}} = 666.7
	\end{matrix} \nonumber
\end{equation}
A torque of $20$ $\mathrm{Nm}$ is not realistic. A better limit would have been $0.6$ $\mathrm{Nm}$, resulting in a force limit of $20$ N.

\subsection{Solver Options}

My problems with the simulation (see Section \ref{sec:SimResults}), is probably due to a competence issue with GPOPS, specifically the solver options.

The dynamics of this problem seemed to me to be similar to the minimum time to climb example GPOPS example. Therefore, I copied the mesh and solver settings from that example.

\subsection{Simulation Results}
\label{sec:SimResults}

Currently I am not able to solve this problem in GPOPS. I am not sure whether the model, limits, or solver options is the problem. The simulation results presented here were found after running GPOPS for a few hours. I've tried many different boundary conditions and limits, but none of the changes I've made seem to have sped up GPOPS.

The robot reaches the correct final position, as seen in Fig. \ref{fig:States}, but the trajectory shown in Fig. \ref{fig:Trajectory} is clearly not optimal.

\begin{figure}[h!]
	\includegraphics{Figures/States.pdf}
	\centering
	\caption{X and Y positions and velocity.}
	\label{fig:States}
\end{figure}

\begin{figure}[h!]
	\includegraphics{Figures/Trajectory.pdf}
	\centering
	\caption{Robot Y vs X trajectory.}
	\label{fig:Trajectory}
\end{figure}

Based on the chosen limits, the robot is allowed to run backwards, as seen by the velocity in Fig. \ref{fig:States} and the angle in Fig. \ref{fig:Angle}. In addition, the forces are very large, as seen in Fig. \ref{fig:Forces}, possibly causing numerical instability. Constraining the limits further is expected to improve the simulation, but I have not been successful yet.

\begin{figure}[h!]
	\includegraphics{Figures/Angle.pdf}
	\centering
	\caption{Robot angle (radians).}
	\label{fig:Angle}
\end{figure}

\begin{figure}[h!]
	\includegraphics{Figures/Forces.pdf}
	\centering
	\caption{Right and left wheel forces.}
	\label{fig:Forces}
\end{figure}

%\bibliographystyle{IEEEtran}
%\bibliography{References}
	
\end{document}